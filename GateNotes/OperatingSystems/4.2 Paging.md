#### 1 Paging
- Non contiguous memory allocation
- The physical memory is split into fixed size blocks
	- Block is the smallest unit of memory
		- A block is a collection of bytes
		- A block is also called as frame in main memory
		- A block in cache is called a cache line or cache block
- The logical memory is split into pages
	- Each page occupies one frame in the main memory
- Address generated by CPU contains
	- Page number and page offset 
	- Page number is used to index the page in page table
	- The page table consists of the base address(relocation address)
- Page table\ 
	- Each process has a page table
	- The page table is stored in a contiguous manner in the main memory ![](./Attachments/Images/page_table_example.png)
- Frame table
	- System-wide table controlled by OS
	- This contains the info of the frames that are 
		- free
		- allotted
			- It contains the frame and the process it is allotted to


#### 2 Context switches with paging
- Context switches are expensive when paging is used 
	- **Why is it expensive?**
		- The page table has to be invalidated each time the there is a context switch between two processes
		- In context switch between threads of the same process, the page table is not invalidated
- **Where to store the page table?**
	- **Approach 1(Not feasible): The page table is a set of registers**
		- Getting the frame number of a page number is fast
		- This is not feasible for large page table
		- The context switch is expensive as all registers needs to be loaded with different value
	- **Approach 2(feasible but slow): The page table is stored in main memory**
		- Getting the page number from the page table takes 2 clock cycle
			- One for accessing the page table in main mem
			- One for fetching the data from the address 
	- **Approach 3: Transition look-aside buffer (TLB)**
		- Associative memory
		- When page number is given
			- All the locations in the TLB are searched in parallel
			- The frame number is returned for the given page number
		- The TLB is small
			- This does not eliminate the need of page table in main mem
			- Contains only a few of the page table entries

#### 3 TLB
- When CPU generates the logical address
	- MMU checks if the page num is present in TLB
		- If present
			- Return the frame number to the MMU for physical address calculation
		- If not present
			- Fetch the frame number from the main memory
			- Add it to the TLB
			- If TLB is full replace an entry form it
				- Some entries cannot be replace(wired down)
- **How to handle context switches when using a TLB?**
	- **Approach 1: The entire TLB is Flushed**
		- This takes more time
	- **Approach 2: The TLB stores ASID(Address space identifier) for each TLB entry**
		- The ASID is unique to each process
		- When logical address is give to MMU
		- MMU checks the TLB for the page number in the TLB
			- If the Page number is present in the TLB
			- MMU checks the ASID of the process and the page table entry
			- If the ASIDs are 
				- Equal
					- Use the frame number for physical address calculations 
				- Not Equal
					- TLB miss, use page table for frame number
					- Add new entry to TLB
- Address resolution with TLB ![](./Attachments/Images/address_resolution_with_tlb.png)

#### 4 Memory access with page table and cache
- Two steps
	- Computing the physical address
	- Fetching data from memory
- **Step 1 (Computing physical address)**
	- Logical address is 32 bits
		- 2<sup>32</sup> Bytes of logical memory
	- Page size 4 KB (2<sup>12</sup> Bytes)
		- Number of pages = total logical mem / page size = 2<sup>20</sup> pages
	- Logical address has
		- 20 bits for the page number 
			- because there is 2<sup>20</sup> pages
		- 12 bits as page offset 
			- because page size is 4 KB
	- Searching for frame number
		- Find the page number in TLB using associative search
			- If there is a matching page number and ASID
				- return the frame number
		- If there is no matching page number in TLB 
		- Search the page table for the page number
			- If the page table has the page number
				- Return the frame number
				- Add the page number and frame to the TLB 
			- Else page fault occurs: The page is not present in main memory or cache
				- MMU raises a TRAP for page fault
				- The register contents are saved
				- The OS gets the logical address
				- The OS checks for a free frame
				- If no free frame, replacement algo selects a frame
				- The replacement frame is written back to disk if it was modified
				- OS executes the necessary commands to 
					- loads the block that contains the page to main memory from the disk
					- **How does the OS know where this page resides on disk?**
						- #TODO-Extras
						- Reference links: 
							- [Stack Exchange explanation](https://superuser.com/questions/1296659/how-does-windows-os-keep-track-of-a-processes-virtual-memory#:~:text=The%20gist%20of%20it%20is,or%2C%20if%20the%20page%20table)
					- Once the data is loaded form disk
						- The page table is updated with the frame number
					- OS returns to the caller, the instruction that caused page fault is executed again
- **Step 2 (fetching the data from memory)**
	- Using the physical address
		- Search the cache using the [[5.2 Cache]] mapping scheme
		- If cache hit
			- return the byte requested
		- If cache miss
			- Search in main memory for the block
			- Move the block to the cache
				- If cache is full
					- Use replacement algo to select a block. If
						- write through: no need to write the block to main memory
						- write back: write the block to main memory if it is dirty
				- Move the required block from main memory to cache and return the data requested

#### 5 Page table Structure
- How is the page table implemented
	- Hierarchical
	- Hashed
	- Inverted

##### 5.1 Hierarchical Page table
- **Issue**
	- When the address space is large, the number of entries in the page table increases
	- More entries requires more space in physical memory
	- Allocating a large amount of contiguous memory is difficult
- **Solution**
	- Split page table so that it is not in contiguous mem locations
- **How to split the page table?**
	- There are multiple levels of page table i.e. the page table itself is paged 
	- Example 2 levels
		- One outer page table
			- This will point to the frame containing another page table
			- The size of this outer page table should be less than or equal to 1 frame. 
				- **Why?**
				- Only if the outer page table size is within 1 frame, the n MSB of the logical address can identify a memory location without any offset bits
					- Reference: [Video explaining multi level paging](https://www.youtube.com/watch?v=PiEq1CoP0ds) 
		- One inner page table
			- This will point to the frame number in physical memory
- Example
	- Given
		- Logical address space 4GB
		- Physical address space is 256 MB
		- Frame size/Page size = 4KB
	- \#bits for logical address
		-  ((4 \* 2<sup>10</sup> MB )\*2<sup>10</sup> KB)\*2<sup>10</sup>B = 32 bits
	- \#bits for physical address
		- (2<sup>8</sup> \* 2<sup>10</sup> KB)\*2<sup>10</sup> B = 28 bits
	- \#bits for the page offset/frame offset
		- page size is 4KB => 12 bits offset
	- \#bits for frame number
		- \#total bits for physical address - \#bits for offset
		- 28 - 12 = 16bits
	- Page table entry size
		- page table entry will contain a frame number
		- from previous step frame number requires 16 bits = 2 Bytes
		- The page table entry will be 2 B
	- With single level paging
		- \#pages will be = Size of logical address space/size of page = 2<sup>32</sup>/2<sup>12</sup> = 2<sup>20</sup>
		- Space required for page table
			- number of pages = 2<sup>20</sup> => number of entries in page table is 2<sup>20</sup>
			- Each entry in page table is 2 B => total size will be 2<sup>21</sup>B
			- In this case the page table should be allocated 2 MB of contiguous memory
			- This is equivalent to 2<sup>9</sup> frames, allocating this many contiguous frames for each process will fill the memory, therefore use another page table level
		- The logical address will be split into to two parts
			- 12 bits for offset
			- 20 bits for the page number
	- With two level paging
		- \#pages in level 2
			- \#pages in level 1/ \#entries per page Or (The size of the level 1 page table)/page size 
				- \#entries per page = page size/one entry size = 4KB/2B = 2<sup>11</sup>
				- \#pages in level 1 = 2<sup>20</sup> (calculated in previous step)
			- 2<sup>20</sup> / 2<sup>11</sup> = 2<sup>9</sup> entries
		- Logical address will be
			- 9 bit for outer page table
			- 11 bits for inner page table
			- 12 bits for page offset
		- Searching
			- The first 9 bits of the logical address is used to find an entry in outer page table
				- The address in the outer page table will hold a frame number of a page
			- Now using the frame number, from previous step
				- access the entry using the 11 bits
				- This entry will have the frame number for the data requested by processor
			- Once the frame number of the data is retrieved, MMU can start the calculate the physical address => Frame number.Page Offset
				- "." represents append

##### 5.2 Hashed paging
- Hash key will be the page number
- Hash value will
	- Contain the page number
	- The frame number of the corresponding page number
	- The next value (strategy to handle collisions if two page numbers have same hash)

##### 5.3 Inverted Page Table
- All processes use the same inverted page table which is of fixed size
	- Number of pages will be always be equal to the number of frames in main memory  
- Each physical frame will have only one entry in page table
	- Each physical frame will be mapped to a process and a page number
	- The page table will be ordered by frame number
		- the first entry in the table will be for frame 1
		- the second entry in the table will be for frame 2 and so on
- When the processor sends a logical address
	- The inverted page table entry is searched one by one
	- Once when the page numbers match after i searches
		- The frame number will be i
- Advantage
	- Reduced page table size
- Drawback
	- Search takes linear time and not constant time
	- This page table does not allow shared frames
		- One frame can be allotted to two pages of different processes in other types of page tables


#### 6 Page replacement algorithms
- Least recently used algorithm
- Optimal page replacement algorithm
	- Swap out the page that won't be used for the longest time
	- This algo requires the future requests 
- Second chance algo
	- Reference bit is set for each page
		- 0: page is not referred 
		- 1: Page was recently referred
	- When page replacement is required
		- if a page has reference bit 0, replace it immediately
		- If reference bit is 1, change it to 0
- Enhanced second chance algo
	- Use reference bit and modified bit
		- if both 0: best page to replace
		- ref bit: 0 and mod bit: 1
			- can be replaced but requires write back
		- ref bit: 1 and mod bit: 0
			- this page will might be used again
		- ref bit: 1 and mod bit: 1
			- this page might be used again and also will require writeback when replaced
			- worst page to replace as it requires writeback and will probably be referenced again


#### 7 Pages with different sizes
#TODO-Extras  


#### 8. Relation between page size and cache line size 
#TODO-Extras 